from pathlib import Path
path = Path('OptiChat/Feas/water_network_generic.py')
text = path.read_text('utf-8')
old = """            coupling_spec = state_spec.get(\"coupling\")\n            if coupling_spec:\n                upstream_node = coupling_spec.get(\"upstream_node\")\n                upstream_state = coupling_spec.get(\"upstream_state\")\n                if upstream_node and upstream_state:\n                    driver_key = (upstream_node, upstream_state)\n                    state_driver_map[key] = driver_key\n                    curve = coupling_spec.get(\"curve\")\n                    label_prefix = coupling_spec.get(\"mode\", \"coupling\")\n                    if curve:\n                        breakpoints, values = curve\n                        if len(breakpoints) >= 2:\n                            bp = [float(v) for v in breakpoints]\n                            val = [float(values[min(i, len(values) - 1)]) for i in range(len(bp))]\n                            state_piecewise_relations.append(\n                                (key, driver_key, bp, val, f\"{label_prefix}:{state_name}\")\n                            )\n                            existing_bounds = state_bounds.get(driver_key, (None, None))\n                            lb, ub = existing_bounds\n                            if lb is None:\n                                lb = min(bp)\n                            if ub is None:\n                                ub = max(bp)\n                            state_bounds[driver_key] = (lb, ub)\n                    sensitivity = coupling_spec.get(\"sensitivity\")\n                    intercept = float(coupling_spec.get(\"intercept\", 0.0))\n                    if sensitivity is not None and not curve:\n                        linear_couplings.append(\n                            (key, driver_key, float(sensitivity), intercept, label_prefix)\n                        )\n\n            coupling_spec = state_spec.get(\"coupling\")\n            if coupling_spec:\n                upstream_node = coupling_spec.get(\"upstream_node\")\n                upstream_state = coupling_spec.get(\"upstream_state\")\n                if upstream_node and upstream_state:\n                    driver_key = (upstream_node, upstream_state)\n                    state_driver_map[key] = driver_key\n                    curve = coupling_spec.get(\"curve\")\n                    label_prefix = coupling_spec.get(\"mode\", \"coupling\")\n                    if curve:\n                        breakpoints, values = curve\n                        if len(breakpoints) >= 2:\n                            bp = [float(v) for v in breakpoints]\n                            val = [float(values[min(i, len(values) - 1)]) for i in range(len(bp))]\n                            state_piecewise_relations.append(\n                                (key, driver_key, bp, val, f\"{label_prefix}:{state_name}\")\n                            )\n                            existing_bounds = state_bounds.get(driver_key, (None, None))\n                            lb, ub = existing_bounds\n                            if lb is None:\n                                lb = min(bp)\n                            if ub is None:\n                                ub = max(bp)\n                            state_bounds[driver_key] = (lb, ub)\n                    sensitivity = coupling_spec.get(\"sensitivity\")\n                    intercept = float(coupling_spec.get(\"intercept\", 0.0))\n                    if sensitivity is not None:\n                        linear_couplings.append(\n                    (key, driver_key, float(sensitivity), intercept, label_prefix)\n                )\n"""
new = """            coupling_spec = state_spec.get(\"coupling\")\n            if coupling_spec:\n                upstream_node = coupling_spec.get(\"upstream_node\")\n                upstream_state = coupling_spec.get(\"upstream_state\")\n                if upstream_node and upstream_state:\n                    driver_key = (upstream_node, upstream_state)\n                    state_driver_map[key] = driver_key\n                    curve = coupling_spec.get(\"curve\")\n                    label_prefix = coupling_spec.get(\"mode\", \"coupling\")\n                    if curve:\n                        breakpoints, values = curve\n                        if len(breakpoints) >= 2:\n                            bp = [float(v) for v in breakpoints]\n                            val = [float(values[min(i, len(values) - 1)]) for i in range(len(bp))]\n                            state_piecewise_relations.append(\n                                (key, driver_key, bp, val, f\"{label_prefix}:{state_name}\")\n                            )\n                            existing_bounds = state_bounds.get(driver_key, (None, None))\n                            lb, ub = existing_bounds\n                            if lb is None:\n                                lb = min(bp)\n                            if ub is None:\n                                ub = max(bp)\n                            state_bounds[driver_key] = (lb, ub)\n                    sensitivity = coupling_spec.get(\"sensitivity\")\n                    intercept = float(coupling_spec.get(\"intercept\", 0.0))\n                    if sensitivity is not None and not curve:\n                        linear_couplings.append(\n                            (key, driver_key, float(sensitivity), intercept, label_prefix)\n                        )\n"""
if old not in text:
    raise SystemExit('pattern not found')
path.write_text(text.replace(old, new, 1), encoding='utf-8')
