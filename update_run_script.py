from pathlib import Path
path = Path('OptiChat/scripts/run_water_network_coupled.py')
text = path.read_text('utf-8')

# Insert helper after imports
helper_insert = "\n\ndef _get_series_values(config_entry: Dict[str, object], periods: Iterable[str]) -> List[float]:\n    values = list(config_entry.get('values', []) or [])\n    default = float(config_entry.get('default', values[-1] if values else 0.0))\n    if len(values) < len(periods):\n        values.extend([default] * (len(periods) - len(values)))\n    return [float(v) for v in values[: len(periods)]]\n\n\n"
if "_get_series_values" not in text:
    insert_point = text.index("def _evaluate_piecewise")
    text = text[:insert_point] + helper_insert + text[insert_point:]

# Update _simulate_greedy_policy to name tailwater_storage and use helper
old_sim_header = "def _simulate_greedy_policy(config: Dict) -> Tuple[Dict[str, object], pd.DataFrame]:"
if old_sim_header in text:
    # replace periods/inflow/demand retrieval and column creation
    old_block = "    periods = list(config[\"horizon\"][\"periods\"])\n    inflow_series = config[\"series\"][\"reservoir_inflow\"]\n    demand_series = config[\"series\"][\"demand_series\"]\n    inflows = [float(v) for v in inflow_series.get(\"values\", [])]\n    demands = [float(v) for v in demand_series.get(\"values\", [])]\n    if len(inflows) < len(periods):\n        inflows += [float(inflow_series.get(\"default\", inflows[-1] if inflows else 0.0))] * (len(periods) - len(inflows))\n    if len(demands) < len(periods):\n        demands += [float(demand_series.get(\"default\", demands[-1] if demands else 0.0))] * (len(periods) - len(demands))\n\n"
    new_block = "    periods = list(config[\"horizon\"][\"periods\"])\n    inflows = _get_series_values(config[\"series\"][\"reservoir_inflow\"], periods)\n    demands = _get_series_values(config[\"series\"][\"demand_series\"], periods)\n\n"
    text = text.replace(old_block, new_block, 1)

    # rename tailwater_buffer usage to storage column
    text = text.replace("tailwater_buffer", "tailwater_storage")

# Add helper to build dataframe from model for optimal solution
if "_build_solution_dataframe" not in text:
    df_helper = "\n\ndef _build_solution_dataframe(model, config: Dict[str, object]) -> pd.DataFrame:\n    periods = list(model.T)\n    inflows = _get_series_values(config['series']['reservoir_inflow'], periods)\n    demands = _get_series_values(config['series']['demand_series'], periods)\n    gate_id = next(edge['id'] for edge in config['edges'] if edge['kind'] == 'gate_flow')\n    pump_id = next(edge['id'] for edge in config['edges'] if edge['kind'] == 'pump')\n\n    records = []\n    for idx, period in enumerate(periods):\n        flow_gate = value(model.flow[(gate_id, period)])\n        flow_pump = value(model.flow[(pump_id, period)])\n        shortage = value(model.shortage[(config['nodes'][2]['id'], period)]) if hasattr(model, 'shortage') else 0.0\n        reservoir_storage = value(model.state[(config['nodes'][0]['id'], 'storage'), period])\n        tailwater_storage = value(model.state[(config['nodes'][1]['id'], 'storage'), period]) if (config['nodes'][1]['states'].get('storage')) else 0.0\n        gate_open = value(model.gate_opening[(gate_id, period)]) if hasattr(model, 'gate_opening') else 0.0\n        gate_cap = value(model.gate_capacity[(gate_id, period)]) if hasattr(model, 'gate_capacity') else flow_gate\n        energy = value(model.sos2_cost[(pump_id, period)]) if hasattr(model, 'sos2_cost') else 0.0\n        records.append({\n            'period': period,\n            'inflow': inflows[idx],\n            'demand': demands[idx],\n            'gate_flow': flow_gate,\n            'pump_flow': flow_pump,\n            'shortage': shortage,\n            'spill': max(0.0, flow_gate - flow_pump),\n            'storage_end': reservoir_storage,\n            'tailwater_storage': tailwater_storage,\n            'gate_opening': gate_open,\n            'gate_capacity': gate_cap,\n            'energy_cost': energy,\n        })\n    return pd.DataFrame(records)\n\n"
    insert_point = text.index("def _simulate_greedy_policy")
    text = text[:insert_point] + df_helper + text[insert_point:]

# Update run_example to use helper when solver succeeds
old_return_block = "        if getattr(model, \"state_index\", []):\n            for (node_id, state_name) in model.state_index:\n                for t in model.T:\n                    metrics[f\"state[{node_id},{state_name},{t}]\"] = value(\n                        model.state[(node_id, state_name), t]\n                    )\n\n        # Enrich metrics with linearization artefacts for MPC usage.\n        for idx, entry in enumerate(export_state_coupling_jacobian(model)):\n            metrics[f\"coupling_slope[{idx}]\"] = entry[\"slope\"]\n            metrics[f\"coupling_intercept[{idx}]\"] = entry[\"intercept\"]\n            metrics[f\"coupling_target[{idx}]\"] = entry[\"target\"]\n            metrics[f\"coupling_driver[{idx}]\"] = entry[\"driver\"]\n\n        for idx, entry in enumerate(export_state_piecewise_tables(model)):\n            metrics[f\"state_piecewise[{idx}]\"] = {\n                \"target\": entry[\"target\"],\n                \"driver\": entry[\"driver\"],\n                \"breakpoints\": entry[\"breakpoints\"],\n                \"values\": entry[\"values\"],\n            }\n\n        metrics[\"gate_piecewise_tables\"] = export_gate_opening_tables(model)\n        metrics[\"sos2_cost_tables\"] = export_sos2_cost_tables(model)\n\n        return metrics\n\n    metrics, df = _simulate_greedy_policy(COUPLED_NETWORK_CONFIG)\n    _write_report(df, metrics)\n    return metrics\n"

new_return_block = "        if getattr(model, \"state_index\", []):\n            for (node_id, state_name) in model.state_index:\n                for t in model.T:\n                    metrics[f\"state[{node_id},{state_name},{t}]\"] = value(\n                        model.state[(node_id, state_name), t]\n                    )\n\n        for idx, entry in enumerate(export_state_piecewise_tables(model)):\n            metrics[f\"state_piecewise[{idx}]\"] = {\n                \"target\": entry[\"target\"],\n                \"driver\": entry[\"driver\"],\n                \"breakpoints\": entry[\"breakpoints\"],\n                \"values\": entry[\"values\"],\n            }\n\n        metrics[\"gate_piecewise_tables\"] = export_gate_opening_tables(model)\n        metrics[\"sos2_cost_tables\"] = export_sos2_cost_tables(model)\n\n        df = _build_solution_dataframe(model, config)\n        _write_report(df, metrics)\n        return metrics\n\n    metrics, df = _simulate_greedy_policy(COUPLED_NETWORK_CONFIG)\n    _write_report(df, metrics)\n    return metrics\n"
text = text.replace(old_return_block, new_return_block, 1)

# Update _write_report to handle tailwater_storage column if available
old_write = "    fig, ax1 = plt.subplots(figsize=(10, 5))\n    ax1.plot(df[\"period\"], df[\"pump_flow\"], label=\"Pump flow\")\n    ax1.plot(df[\"period\"], df[\"demand\"], label=\"Demand\", linestyle=\"--\")\n    ax1.plot(df[\"period\"], df[\"storage_end\"], label=\"Storage\", color=\"tab:green\")\n    ax1.set_xlabel(\"Period\")\n    ax1.set_ylabel(\"Flow / Storage\")\n    ax1.legend(loc=\"upper right\")\n"
new_write = "    fig, ax1 = plt.subplots(figsize=(10, 5))\n    ax1.plot(df[\"period\"], df[\"pump_flow\"], label=\"Pump flow\")\n    ax1.plot(df[\"period\"], df[\"demand\"], label=\"Demand\", linestyle=\"--\")\n    ax1.plot(df[\"period\"], df[\"storage_end\"], label=\"Reservoir storage\", color=\"tab:green\")\n    if \"tailwater_storage\" in df.columns:\n        ax1.plot(df[\"period\"], df[\"tailwater_storage\"], label=\"Tailwater storage\", color=\"tab:red\")\n    ax1.set_xlabel(\"Period\")\n    ax1.set_ylabel(\"Flow / Storage\")\n    ax1.legend(loc=\"upper right\")\n"
text = text.replace(old_write, new_write, 1)

path.write_text(text, encoding='utf-8')
